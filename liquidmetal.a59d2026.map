{"version":3,"sources":["liquidmetal.js"],"names":["LiquidMetal","SCORE_NO_MATCH","SCORE_MATCH","SCORE_TRAILING","SCORE_TRAILING_BUT_STARTED","SCORE_BUFFER","WORD_SEPARATORS","lastScore","lastScoreArray","score","string","abbrev","length","allScores","search","toLowerCase","_scoreAll","maxScore","maxArray","i","scores","scoreSum","j","searchIndex","abbrIndex","started","charAt","trailScore","fillArray","push","slice","c","index","indexOf","scoreIndex","isNewWord","isUpperCase","array","value","from","to"],"mappings":"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","file":"liquidmetal.a59d2026.map","sourceRoot":"../demo","sourcesContent":["/**\n * LiquidMetal, version: 1.2.1 (2012-04-21)\n *\n * A mimetic poly-alloy of Quicksilver's scoring algorithm, essentially\n * LiquidMetal.\n *\n * For usage and examples, visit:\n * http://github.com/rmm5t/liquidmetal\n *\n * Licensed under the MIT:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * Copyright (c) 2009-2012, Ryan McGeary (ryan -[at]- mcgeary [*dot*] org)\n */\nvar LiquidMetal = (function() {\n  var SCORE_NO_MATCH = 0.0;\n  var SCORE_MATCH = 1.0;\n  var SCORE_TRAILING = 0.8;\n  var SCORE_TRAILING_BUT_STARTED = 0.9;\n  var SCORE_BUFFER = 0.85;\n  var WORD_SEPARATORS = \" \\t_-\";\n\n  return {\n    lastScore: null,\n    lastScoreArray: null,\n\n    score: function(string, abbrev) {\n      // short circuits\n      if (abbrev.length === 0) return SCORE_TRAILING;\n      if (abbrev.length > string.length) return SCORE_NO_MATCH;\n\n      // match & score all\n      var allScores = [];\n      var search = string.toLowerCase();\n      abbrev = abbrev.toLowerCase();\n      this._scoreAll(string, search, abbrev, -1, 0, [], allScores);\n\n      // complete miss\n      if (allScores.length == 0) return 0;\n\n      // sum per-character scores into overall scores,\n      // selecting the maximum score\n      var maxScore = 0.0, maxArray = [];\n      for (var i = 0; i < allScores.length; i++) {\n        var scores = allScores[i];\n        var scoreSum = 0.0;\n        for (var j = 0; j < string.length; j++) { scoreSum += scores[j]; }\n        if (scoreSum > maxScore) {\n          maxScore = scoreSum;\n          maxArray = scores;\n        }\n      }\n\n      // normalize max score by string length\n      // s. t. the perfect match score = 1\n      maxScore /= string.length;\n\n      // record maximum score & score array, return\n      this.lastScore = maxScore;\n      this.lastScoreArray = maxArray;\n      return maxScore;\n    },\n\n    _scoreAll: function(string, search, abbrev, searchIndex, abbrIndex, scores, allScores) {\n      // save completed match scores at end of search\n      if (abbrIndex == abbrev.length) {\n        // add trailing score for the remainder of the match\n        var started = (search.charAt(0) == abbrev.charAt(0));\n        var trailScore = started ? SCORE_TRAILING_BUT_STARTED : SCORE_TRAILING;\n        fillArray(scores, trailScore, scores.length, string.length);\n        // save score clone (since reference is persisted in scores)\n        allScores.push(scores.slice(0));\n        return;\n      }\n\n      // consume current char to match\n      var c = abbrev.charAt(abbrIndex);\n      abbrIndex++;\n\n      // cancel match if a character is missing\n      var index = search.indexOf(c, searchIndex);\n      if (index == -1) return;\n\n      // match all instances of the abbreviaton char\n      var scoreIndex = searchIndex; // score section to update\n      while ((index = search.indexOf(c, searchIndex+1)) != -1) {\n        // score this match according to context\n        if (isNewWord(string, index)) {\n          scores[index-1] = 1;\n          fillArray(scores, SCORE_BUFFER, scoreIndex+1, index-1);\n        }\n        else if (isUpperCase(string, index)) {\n          fillArray(scores, SCORE_BUFFER, scoreIndex+1, index);\n        }\n        else {\n          fillArray(scores, SCORE_NO_MATCH, scoreIndex+1, index);\n        }\n        scores[index] = SCORE_MATCH;\n\n        // consume matched string and continue search\n        searchIndex = index;\n        this._scoreAll(string, search, abbrev, searchIndex, abbrIndex, scores, allScores);\n      }\n    }\n  };\n\n  function isUpperCase(string, index) {\n    var c = string.charAt(index);\n    return (\"A\" <= c && c <= \"Z\");\n  }\n\n   function isNewWord(string, index) {\n    var c = string.charAt(index-1);\n    return (WORD_SEPARATORS.indexOf(c) != -1);\n  }\n\n  function fillArray(array, value, from, to) {\n    for (var i = from; i < to; i++) { array[i] = value; }\n    return array;\n  }\n})();"]}